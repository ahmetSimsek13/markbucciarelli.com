<section>

<h2>Why Elm?</h2>

<p>I am by no means a JavaScript expert. I've built a total of four commercial
applications; one with Backbone and three with ExtJS.  For my day job I
primarily code in Java and ExtJS.</p>

<p>My Elm experience was a side-project where I wanted a calendar widget where
people could quickly pick multiple dates from the next three months as a way of
filtering local events.</p>

<p>Over the course of a month or so, I was able to learn enough of Elm that I
could build this date picker.  I enjoyed programming in Elm so much that I
decided to work 100% with Elm and to learn Haskell.</p>

<p>Here are the reasons why.</p>

<h3>There are great learning materials.</h3>

<p>I started with the free, on-line class <a
href="http://courses.knowthen.com/p/elm-for-beginners">Elm For Beginners</a>,
<i>Start Building Web Apps using Elmlang Today</i>.  Short video lessons,
ranging in length from three to eleven minutes long, each focusing on one
specific topic was a great introduction.</p>

<p>I made it up through lesson 13 (out of 18) before I started coding.</p>

<h3>The compiler was a revelation</h3>

<p>It is hard to overstate this.  I ended up writing about 600 lines of Elm
code in all to accept today's date, render the next three months, respond to
clicks on the dates and keep track of which dates were currently selected.</p>

<p>The process of writing in Elm was different than any other language I have
written in before.  Typically, I use TDD: write a stubbed function, write a
test, and then flesh out the feature.  In Elm, I wrote the code and then
``just'' had to get the code to compile.  Just is in quotes because it
initially it took me a <em>long</em> time to figure out the compilation
issues.</p>

<p>So ... write a basic feature, spend a long time getting it to compile.
Then, write the next feature, and spend a little less time getting it to
compile.  Finally, after getting the last feature to compile, I tested it in a
browser.</p>

<p>It worked.</p>


<h3>Java is strongly typed, but Elm felt so different.</h3>

<ul>

<li>every if requires an 
else<label for="mn-else" class="margin-toggle">&#8853;</label>,
<input type="checkbox" id="mn-else" class="margin-toggle"/>
<span class="marginnote">
Of course you can do this with Java, and it's good practice, but
it is required by the compiler with Elm.
</span> otherwise the compiler fails.
</li>

<li>it is so easy to define a type: <code>type alias Year = Int</code>; now you
can use that type as function argument or return value, which is very
expressive at a small cost</li> 

<li>union types (AKA algebraic types) are really useful; for example, the
compiler will fail if you have a case statement that ignores one of the types
in the union.</li>

<li>partial functions are handy, compact, clever and expressive; they feel
comfortable very quickly.</li>

</ul>


<h3>Similarities with CQRS</h3>

<p>The whole model/view/update pattern felt very similar to the command/query
pattern.  The Elm model defines state, the update step takes a command and
updates state, and the view step takes state and renders a view.</p>

<p>In the command/query responsibility separation pattern, one object processes
commands and a different object responds to view requests.  Very similar in how
responsibilities are split up.</p>

<p>I'm a fan of CQRS, so this was a plus.</p>

</section>

<section>
<h2>And now onto Haskell!</h2>

<p>I think people in the Haskell world that criticize Elm do Haskell a
disservice.  Elm is an easy gateway to Haskell and there are lots of JavaScript
programmers.  Perhaps the visual of a herd of JavaScript programmers flooding
to Haskell is not a pretty picture.</p> 

<p>After my experience with the Elm compiler, I wanted to get the same benefits
when writing back end code, so I picked up Haskell.  My experience with Elm (and
Erlang before that) made it easier to start being productive with Haskell.</p>

</section>
