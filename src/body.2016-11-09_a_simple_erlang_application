<section>

<h2>The Code</h2>

<h3>Directory Structure</h3>

            <pre class="code with-wrapping fullwidth">
<line>.</line>
<line>├── Makefile</line>
<line>├── ebin</line>
<line>└── src</line>
<line>    ├── erlsrv.app.src</line>
<line>    ├── erlsrv.erl</line>
<line>    ├── es_callback.erl</line>
<line>    └── es_sup.erl</line>
</pre>

<p>The Erlang <a href="http://erlang.org/doc/design_principles/applications.html">documentation</a> mentions four directories (src, ebin, priv and include) but the application started fine with just two.</p>

<h3>Makefile</h3>

            <pre class="code with-wrapping fullwidth">
<line>all: ebin/es_sup.beam ebin/es_callback.beam ebin/erlsrv.app ebin/erlsrv.beam</line>
<line></line>
<line>ELLI=${HOME}/src/elli</line>
<line>${ELLI}/ebin:</line>
<line>	(cd ${ELLI} ; make)</line>
<line></line>
<line>ebin/%.beam: src/%.erl ${ELLI}/ebin</line>
<line>	ERL_LIBS=${ELLI} erlc -o ebin/ $<</line>
<line></line>
<line>ebin/erlsrv.app: src/erlsrv.app.src</line>
<line>	cp $? $@</line>
<line></line>
<line>.PHONY: clean</line>
<line>clean:</line>
<line>	rm -f ebin/*</line>
</pre>

<p><code>ERL_LIBS</code> makes this work.  I cloned the <a href="https://github.com/knutin/elli">Elli</a> repository under <code>$HOME/src</code> and set <code>ERL_LIBS</code> to that before calling <code>erlc</code>.  A simple way to manage dependencies that is built in to Erlang.</p>


            <blockquote>

<p>Environment variable ERL_LIBS (defined in the operating system) can be used to define more library directories to be handled in the same way as the standard OTP library directory described above, except that directories without an ebin directory are ignored.</p>

<p>All application directories found in the additional directories appears before the standard OTP applications, except for the Kernel and STDLIB applications, which are placed before any additional applications. In other words, modules found in any of the additional library directories override modules with the same name in OTP, except for modules in Kernel and STDLIB.</p>

<p>Environment variable ERL_LIBS (if defined) is to contain a colon-separated (for Unix-like systems) or semicolon-separated (for Windows) list of additional libraries.</p>

                <footer>Ericsson AB. <cite><a href="http://erlang.org/doc/man/code.html">erlang.org code</a></cite> (retrieved November 6, 2016)</footer>
            </blockquote>

<h3>src/erlsrv.app.src</h3>

            <pre class="code with-wrapping fullwidth">
<line>{application, erlsrv, [{mod, {erlsrv,[]}}]}.</line>
</pre>

<p>The smallest possible application configuration file.</p>

<h3>src/erlsrv.erl</h3>

            <pre class="code with-wrapping fullwidth">
<line>-module(erlsrv).</line>
<line>-behavior(application).</line>
<line></line>
<line>-export([start/2, stop/1]).</line>
<line></line>
<line>start(_Type, _Args) -> es_sup:start_link().</line>
<line></line>
<line>stop(_State) -> ok.</line>
</pre>

<p>The job of the application behavior is to start the main supervisor.</p>


<h3>src/es_callback.erl</h3>

            <pre class="code with-wrapping fullwidth">
<line>-module(es_callback).</line>
<line>-export([handle/2, handle_event/3]).</line>
<line></line>
<line>-include_lib("elli/include/elli.hrl").</line>
<line>-behaviour(elli_handler).</line>
<line></line>
<line>% Dispatch to handler functions</line>
<line>handle(Req, _Args) -></line>
<line>    handle(Req#req.method, elli_request:path(Req), Req).</line>
<line></line>
<line>handle('GET',[<<"hello">>, <<"world">>], _Req) -></line>
<line>    {ok, [], <<"Hello World!">>};</line>
<line></line>
<line>handle(_, _, _Req) -></line>
<line>    {404, [], <<"Not Found">>}.</line>
<line></line>
<line>%% @doc: Handle request events, like request completed, exception</line>
<line>%% thrown, client timeout, etc. Must return 'ok'.</line>
<line>handle_event(_Event, _Data, _Args) -></line>
<line>    ok.</line>
</pre>

<p>Dispatch HTTP calls to handlers.  Elli spawns a process for each request so they are isolated from each other.</p>
<p>This is the file that will grow as I build a server that does something.</p>


<h3>src/es_sup.erl</h3>

            <pre class="code with-wrapping fullwidth">
<line>-module(es_sup).</line>
<line>-behaviour(supervisor).</line>
<line>-export([start_link/0]).</line>
<line>-export([init/1]).</line>
<line></line>
<line>start_link() -></line>
<line>    supervisor:start_link({local, ?MODULE}, ?MODULE, []).</line>
<line></line>
<line>init([]) -></line>
<line>    ElliOpts = [{callback, es_callback}, {port, 3000}],</line>
<line>    ElliSpec = {</line>
<line>        es_http,</line>
<line>        {elli, start_link, [ElliOpts]},</line>
<line>        permanent,</line>
<line>        5000,</line>
<line>        worker,</line>
<line>        [elli]},</line>
<line></line>
<line>    {ok, { {one_for_one, 5, 10}, [ElliSpec]} }.</line>
</pre>

<p>The supervisor for Elli.  Copied right from Elli's <a href="https://github.com/knutin/elli">github readme</a>.</p>

<h2>Running the application</h2>


            <pre class="code with-wrapping fullwidth">
<line>$ ERL_LIBS=$HOME/src/elli erl -pa ebin</line>
<line>Erlang/OTP 19 [erts-8.0.1] [source-ca40008] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false]</line>
<line></line>
<line>Eshell V8.0.1  (abort with ^G)</line>
<line>1> application:start(erlsrv).</line>
<line>ok</line>
<line>2></line>
</pre>

<p>Note the use of ERL_LIBS when starting interpreter.</p>

            <pre class="code with-wrapping fullwidth">
<line>$ curl -v http://127.0.0.1:3000/hello/world</line>
<line>*   Trying 127.0.0.1...</line>
<line>* Connected to 127.0.0.1 (127.0.0.1) port 3000 (#0)</line>
<line>> GET /hello/world HTTP/1.1</line>
<line>> Host: 127.0.0.1:3000</line>
<line>> User-Agent: curl/7.49.1</line>
<line>> Accept: */*</line>
<line>> </line>
<line>< HTTP/1.1 200 OK</line>
<line>< Connection: Keep-Alive</line>
<line>< Content-Length: 12</line>
<line>< </line>
<line>* Connection #0 to host 127.0.0.1 left intact</line>
<line>Hello World!$</line>
</pre>

<h2>Notes</h2>

<h3>Goals</h3>
<ol>
<li>simplest code possible</li>
<li>want to understand and learn Erlang, not get some MVP up quickly that works like ``magic''</li>
<li>ssl</li>
<li>basic auth</li>
</ol>

<h3>Why no rebar?</h3>

            <pre class="code with-wrapping fullwidth">
<line>$ cd $HOME/src/rebar3/</line>
<line>$ du -sh .</line>
<line>6.5M	.</line>
<line>$ </line>
</pre>

<p>Violates goal #1.</p>


<h3>Strange behavior when no mod in application configuration file.</h3>

<h3>Really minimal HTTP server---no logging or Date header.</h3>

<h3>Why Elli?</h3>
<p>Tried mochiweb, but I was too new to Erlang.</p>
<p>Tried yaws and while creating an app was easy, but I got confused by yapp and embedded options.</p>
<p>Tried cowboy, but tutorial didn't work for me (most likely due to my ignorance).</p>
<p>Finally found Elli, which explained how it extended mochiweb which was simplest after all.</p>

<h3>Next steps ...</h3>

<p>In no particular order:</p>

<ul>
<li>hot code reload</li>
<li>build a release</li>
<li>wrap into command-line with escript or sh</li>
<li>add logging and basic auth</li>
</ul>

